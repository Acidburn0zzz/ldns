<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Making a small application with ldns</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="ldns tutorial"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="ldns tutorial"
HREF="index.html"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>ldns tutorial</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="index.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
>&nbsp;</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="AEN52"
>2. Making a small application with ldns</A
></H1
><P
>&#13;In this tutorial we will make a small application which takes a domain name
and looks up the MX records for this domain. We will call this program:
'mx'.
    </P
><P
>&#13;	The general flow of the program is as follows:
		<P
></P
><OL
TYPE="1"
><LI
><P
>make a resolver structure,</P
></LI
><LI
><P
>use the resolver to generate an mx query,</P
></LI
><LI
><P
>print the result.</P
></LI
></OL
>	
	</P
><P
>&#13;First we begin with some boiler plating:
<PRE
CLASS="programlisting"
>&#13;      1 /*
      2  * mx is a small programs that prints out the mx records
      3  * for a particulary domain
      4  */
      5
      6 #include &#60;stdio.h&#62;
      7 
      8 #include &#60;ldns/dns.h&#62;
      9
     10 int
     11 usage(FILE *fp, char *prog) {
     12         fprintf(fp, "%s zone\n", prog);
     13         fprintf(fp, "  print out the mx for the domain\n");
     14         return 0;
     15 }
     16
</PRE
>
Line 9 is the important one here, this includes all the stuff we need
from ldns.

<PRE
CLASS="programlisting"
>&#13;     17 int
     18 main(int argc, char *argv[])
     19 {
     20         ldns_resolver *res;
     21         ldns_rdf *domain;
     22         ldns_pkt *p;
     23         ldns_rr_list *mx;
     24
     25
     26         if (argc != 2) {
     27                 usage(stdout, argv[0]);
     28                 exit(1);
     29         } else {
     30                 /* create a rdf from the command line arg */
     31                 domain = ldns_dname_new_frm_str(argv[1]);
     32                 if (!domain) {
     33                         usage(stdout, argv[0]);
     34                         exit(1);
     35                 }
     36                 /* transform it in a string for the error msg (if needed) */
     38         }
</PRE
>
Here we parse the arguments. We create a new rdf structure which contain the domain
name that we got from the commandline. 

<PRE
CLASS="programlisting"
>&#13;     39
     40         /* create a new resolver from /etc/resolv.conf */
     41         res = ldns_resolver_new_frm_file(NULL);
     42         if (!res) {
     43			exit(1);
     44         }
</PRE
>
At line 41 we create a new resolver structure. When it's argument is NULL it uses
<TT
CLASS="filename"
>/etc/resolv.conf</TT
> to setup the resolver structure.

<PRE
CLASS="programlisting"
>&#13;     45         
     46
     47         /* use the resolver to send it a query for the mx
     48          * records of the domain given on the command line
     49          */
     50         p = ldns_resolver_query(res, domain, LDNS_RR_TYPE_MX, LDNS_RR_CLASS_IN, LDNS_RD);
</PRE
>
At line 50 we do the actual query. The ldns_resolver_query command returns ldns_pkt* structure,
with the reply from the nameserver. As we look at the function call, we see that we do a
query for a RR type 'MX' in the class 'IN' and we set the RD (recursion desired) flag on the
qeury.

<PRE
CLASS="programlisting"
>&#13;     51         if (!p)  {
     52
     53                 exit(1);
     54         } else {
     55                 /* retrieve the MX records from the answer section of that
     56                  * packet
     57                  */
     58                 mx = ldns_pkt_rr_list_by_type(p, LDNS_RR_TYPE_MX, LDNS_SECTION_ANSWER);
</PRE
>
On line 58 we look inside the packet to see if we got any MX records back for our query. We look
only inside the answer section of the packet.

<PRE
CLASS="programlisting"
>&#13;     59                 if (!mx) {
     60                         fprintf(stderr,
     61                                         " *** invalid answer name %s after MX query for %s\n        ",
     62                                         argv[1],
     63                                         argv[1]);
     64                         exit(1);
     65                 } else {
     66                         /* sort the list nicely */
     67                         ldns_rr_list_sort(mx);
     68                         /* print the rrlist to stdout */
     69                         ldns_rr_list_print(stdout, mx);
     70                 }
</PRE
>
Here we sort the list and print it to stdout.

<PRE
CLASS="programlisting"
>&#13;     71         }
     72         return 0;
     73 }
</PRE
>
</P
><P
>&#13;This example shows that with a fairly short C program you can already do
complex tasks.
</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>&nbsp;</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>ldns tutorial</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>&nbsp;</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>