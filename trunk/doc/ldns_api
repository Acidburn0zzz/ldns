LibDNS - API

   LibDNS (or lDNS) is modelled after the Net::DNS perl library. It has
   been shown that Net::DNS  can be used very efficiently for 
   programming DNS aware applications.

   The current [need to look at bind lwres_ XXX] C library implementations
   of DNS a rarely more than a wrapper for getaddrinfo(). Especially the
   handling of Resource Records and RRsets is missing from those libraries.
   This is the gap lDNS wants to fill.

   The lDNS API consist of two layers. The top-layer, this is
   what is actually exported to the application via the library. And the
   bottom-layer, this is what lDNS needs to compile and function.

Bottom Layer
   lDNS is currently only dependent on libc and uses only 4 system calls:
   send/recvfrom (for udp) and sendto/recv (for tcp) [XXX Not checked if
   this is correct, i.e. is sendto for tcp?]

   Furhter more, it is to be expected that lDNS is going to depend on
   a cryptographic library. Probably openSSL.

   And some netdb-functions. [Jelte plz extend]

Top Layer
   As said, lDNS is modelled after Net::DNS, therefor its API looks very
   much like the one used for Net::DNS. Some modification are made
   ofcourse, because not all functionality of Perl can be caught in C.

   The following API details are a rewrite of 'perldoc Net::DNS:XXX' where
   XXX is the actual manpage. At the top of each section it will state from
   which Perl manual page it has been converted.

API
   From Net::DNS - Perl interface to the DNS resolver

  Resolver Structures [ldns_resolver]
    ldns_resolver* ldns_resolver_new(void)

    A program can have multiple resolver structurs, each maintaining its own
    state information such as the nameservers to be queried, whether
    recursion is desired, etc.

  Packet Structures [ldns_pkt]
    ldns_pkt* ldns_pkt_new(void)

    ldns_resolver queries return ldns_pkt structures. A ldns_pkt structure
    have five sections:

    *  The header section, a ldns_hdr structure.

    *  The question section, a ldns_rr_list structure.

    *  The answer section, a ldns_rr_list structure.

    *  The authority section, a ldns_rr_list structure.

    *  The additional section, a ldns_rr_list structure.

  Update Objects [NOT IMPL]
    [NOT IMPL]

  Header Structures [ldns_hdr]
    ldns_hdr represents the header section of a DNS packet.

  Question Section [no special type is used]
    ldns_rr_list structure. A list of RRs in the Question section of a DNS
    packet.

  Answer Section [no special type is used]
    ldns_rr_list structure. A list of RRs in the Question section of a DNS
    packet.

  Authority Section [no special type is used]
    ldns_rr_list structure. A list of RRs in the Question section of a DNS
    packet.
    
  Additional Section [no special type is used]
    ldns_rr_list structure. A list of RRs in the Question section of a DNS
    packet.

  RR List Structure [ldns_rr_list]
    An array containing Resource Records (RR).
   
  RR Structures [ldns_rr]
    A single Resource Record.


Function on ldns_resolver

  ldns_version(resolver *res)
    Returns the version of lDNS.

  ldns_mx(ldns_resolver *res, char *dname)
    Returns a ldns_rr_list representing the MX records
    for the specified name; the list will be sorted by preference. Returns
    an empty list if the query failed or no MX records were found.

    This method does not look up A records -- it only performs MX queries.

--- FROM HERE IT ONLY TALKS ABOUT DYNAMIC UPDATES - WHAT TO DO WITH THAT -

  yxrrset [NOT IMPL]
    Use this method to add an "RRset exists" prerequisite to a dynamic
    update packet. There are two forms, value-independent and
    value-dependent:

        # RRset exists (value-independent)
        $update->push(pre => yxrrset("host.example.com A"));

  nxrrset [NOT IMPL]
    Use this method to add an "RRset does not exist" prerequisite to a
    dynamic update packet.

        $packet->push(pre => nxrrset("host.example.com A"));

    Meaning: No RRs with the specified name and type can exist.

    Returns a "Net::DNS::RR" object or "undef" if the object couldn't be
    created.

  yxdomain [NOT IMPL]
    Use this method to add a "name is in use" prerequisite to a dynamic
    update packet.

        $packet->push(pre => yxdomain("host.example.com"));

    Meaning: At least one RR with the specified name must exist.

    Returns a "Net::DNS::RR" object or "undef" if the object couldn't be
    created.

  ldns_nxdomain [NOT IMPL]
    Use this method to add a "name is not in use" prerequisite to a dynamic
    update packet.

        $packet->push(pre => nxdomain("host.example.com"));

    Meaning: No RR with the specified name can exist.

    Returns a "Net::DNS::RR" object or "undef" if the object couldn't be
    created.

  ldns_rr_add(ldns_resolver *res, ldns_rr *r) [NOT IMPL]
    Use this method to add RRs to a zone.

        $packet->push(update => rr_add("host.example.com A 10.1.2.3"));

    Meaning: Add this RR to the zone.

    RR objects created by this method should be added to the "update"
    section of a dynamic update packet. The TTL defaults to 86400 seconds
    (24 hours) if not specified.

    Returns a "Net::DNS::RR" object or "undef" if the object couldn't be
    created.

  ldns_rr_del(ldns_resolver *res, ldns_rr *r) [NOT IMPL]
    Use this method to delete RRs from a zone. There are three forms: delete
    an RRset, delete all RRsets, and delete an RR.

        # Delete an RRset.
        $packet->push(update => rr_del("host.example.com A"));

    Meaning: Delete all RRs having the specified name and type.

        # Delete all RRsets.
        $packet->push(update => rr_del("host.example.com"));

    Meaning: Delete all RRs having the specified name.

        # Delete an RR.
        $packet->push(update => rr_del("host.example.com A 10.1.2.3"));

    Meaning: Delete all RRs having the specified name, type, and data.

    RR objects created by this method should be added to the "update"
    section of a dynamic update packet.

    Returns a "Net::DNS::RR" object or "undef" if the object couldn't be
    created.
